<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", sans-serif;
        background-color: #fff9f9;
      }
      .country {
        /* fill: #9f9f9f; */
        cursor: pointer;
      }
      .country:hover {
        fill: #d04b4b;
      }
      .map {
        background-color: white;
        border: 1px solid #d9d9d9;
        display: flex;
        justify-content: space-between;
        padding: 32px;
        max-height: 600px;
        border-radius: 10px;
      }

      .countries-list {
        display: flex;
        flex-direction: column;
        overflow: auto;
        list-style-type: none;
        padding: 0 1rem;
      }

      .country-item {
        display: flex;
        align-items: center;
        padding: 0.75rem 0;
        border-bottom: 1px solid #d9d9d9;
        font-size: 14px;
      }

      .country-item__image {
        width: 18px;
        margin-right: 6px;
        display: block;
      }

      .country-item__indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 16px;
      }
      .container {
        margin: 0 auto;
        padding: 1rem 2rem;
      }

      .header {
        background-color: #d04b4b;
        color: white;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="container">
        <span>CoronaTrack</span>
      </div>
    </header>
    <div class="container">
      <div class="map">
        <svg id="legend-svg"></svg>
        <svg id="map" width="1000" height="536"></svg>
        <ul id="countries_list" class="countries-list">
          <li></li>
        </ul>
      </div>
      <div>
        <svg id="linegraph"></svg>
      </div>
    </div>

    <div id="my_graph"></div>
    <script>
      const getMap = async () => {
        const mapData = await d3.json(
          "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
        );
        return mapData;
      };

      const dataLink =
        "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv";

      const getData = async () => {
        const data = await d3.csv(dataLink, (d) => {
          return {
            iso_code: d.iso_code,
            location: d.location,
            date: d3.timeParse("%Y-%m-%d")(d.date),
            cases: d.new_cases,
            vaccinations: d.new_vaccinations,
          };
        });
        return data;
      };

      map = getMap();

      getData().then((data) => {
        const svg = d3.select("#map");
        let width = +svg.attr("width");
        let height = +svg.attr("height");

        const projection = d3
          .geoNaturalEarth1()
          // .center([7, 31]) // GPS of location to zoom on
          .scale(100) // This is like the zoom
          .translate([width / 2, height / 2]);

        // project.fitSize([900, 500], geojson);
        // Load external data and boot
        casesRollup = data.filter((item) => item.iso_code.length <= 3);

        casesRollup = d3.rollup(
          casesRollup,
          (v) => d3.sum(v, (d) => d.cases),
          (d) => d.iso_code
        );

        countryToCode = data.reduce((result, item) => {
          result[item.iso_code] = item.location;
          return result;
        }, {});

        var color = d3
          .scaleLinear()
          .domain([1000000, 25000000])
          .range(["#181010", "#FC0000"]);

        const sortedRollup = Array.from(casesRollup, ([key, value]) => ({
          key,
          value,
        })).sort((a, b) => d3.descending(a.value, b.value));

        var scale = d3.scaleLinear().domain([0, 99030129]).range([0, 1]);

        // data = d3.group(data, (d) => d.location);

        // mostCases = data.sort((a, b) => d3.descending(a[1].))

        // COUNTRIES TEXT ON RIGHT
        var g = d3
          .select("#countries_list")
          .selectAll("li")
          .data(sortedRollup)
          .join("li")
          .attr("class", "country-item");

        g.append("span")
          .attr("class", "country-item__indicator")
          .style("background-color", (d) => color(d.value));

        g.append("img")
          .attr("class", "country-item__image")
          .attr("crossorigin", "anonymous")

          .attr("src", (d) => `https://countryflagsapi.com/png/${d.key}`);

        var countryText = g
          .append("div")
          .attr("data-country", (d) => d.key)
          .style("flex", "1")
          .style("display", "flex")
          .style("justify-content", "space-between");

        countryText
          .append("span")
          .text((d) => countryToCode[d.key])
          .style("font-weight", "bold");

        countryText
          .append("span")
          .text((d) => d.value.toLocaleString())
          .style("flex", 1)
          .style("text-align", "right");

        getMap().then((mapData) => {
          // project.fitSize([900, 500], geojson);
          const getRanges = sortedRollup[0].value / 5;
          console.log([
            getRanges,
            getRanges * 2,
            getRanges * 3,
            getRanges * 4,
            getRanges * 5,
          ]);
          // var color = d3
          //   .scaleThreshold()
          //   .domain([1000000, 5000000, 10000000, 50000000, 100000000])
          //   .range(["green", "darkgreen", "orange", "yellow", "red"]);

          projection.fitSize([1000, 536], mapData);
          const getCountryText = (name) => {
            return d3.selectAll("[data-country]").filter(function () {
              return d3.select(this).attr("data-country") === name;
            });
          };
          svg
            .on("wheel", function (e) {
              //zoomend needs mouse coords
              initX = d3.pointer(e, this);
              console.log(initX);
            })
            .append("g")

            .selectAll("path")
            .data(mapData.features)
            .join("path")
            .attr("class", "country")
            .attr("d", d3.geoPath().projection(projection))
            .style("stroke", "#000000")
            .attr("fill", (d) => {
              return color(casesRollup.get(d.id));
            })
            .on("mouseover", function (e, d) {
              console.log(d);
              d3.select(this).attr("fill", "blue");
              getCountryText(d.id).style("color", "red");
            })
            .on("mouseout", function (e, d) {
              d3.select(this).attr("fill", (d) => color(casesRollup.get(d.id)));
              getCountryText(d.id).style("color", "black");
            });

          const margin = { top: 10, right: 30, bottom: 30, left: 60 },
            width = window.document.body.clientWidth,
            height = 400;

          worldData = data.filter((item) => item.location == "World");

          console.log(worldData);

          // append the svg object to the body of the page
          const linesvg = d3
            .select("#my_graph")
            .append("svg")
            .attr("width", width)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          // Add X axis --> it is a date format
          const x = d3
            .scaleTime()
            .domain(d3.extent(worldData, (d) => d.date))
            .range([0, width]);
          xAxis = linesvg
            .append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x));

          // Add Y axis
          const y = d3
            .scaleLinear()
            .domain([0, d3.max(worldData, (d) => +d.cases)])
            .range([height, 0]);
          yAxis = linesvg.append("g").call(d3.axisLeft(y));

          // Add a clipPath: everything out of this area won't be drawn.
          const clip = linesvg
            .append("defs")
            .append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("x", 0)
            .attr("y", 0);

          // Add brushing
          const brush = d3
            .brushX() // Add the brush feature using the d3.brush function
            .extent([
              [0, 0],
              [width, height],
            ]) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
            .on("end", updateChart); // Each time the brush selection changes, trigger the 'updateChart' function

          // Create the area variable: where both the area and the brush take place
          const area = linesvg.append("g").attr("clip-path", "url(#clip)");

          // Create an area generator
          const areaGenerator = d3
            .area()
            .x((d) => x(d.date))
            .y0(y(0))
            .y1((d) => y(d.cases));

          // Add the area
          area
            .append("path")
            .datum(worldData)
            .attr("class", "myArea") // I add the class myArea to be able to modify it later on.
            .attr("fill", "rgba(228, 23, 23, 0.1)")
            .attr("fill-opacity", 0.1)
            .attr("stroke", "#D04B4B")
            .attr("stroke-width", 2)
            .attr("d", areaGenerator);

          // Add the brushing
          area.append("g").attr("class", "brush").call(brush);

          // A function that set idleTimeOut to null
          let idleTimeout;
          function idled() {
            idleTimeout = null;
          }

          // A function that update the chart for given boundaries
          function updateChart(event) {
            // What are the selected boundaries?
            extent = event.selection;

            // If no selection, back to initial coordinate. Otherwise, update X axis domain
            if (!extent) {
              if (!idleTimeout) return (idleTimeout = setTimeout(idled, 350)); // This allows to wait a little bit
              x.domain([4, 8]);
            } else {
              x.domain([x.invert(extent[0]), x.invert(extent[1])]);
              area.select(".brush").call(brush.move, null); // This remove the grey brush area as soon as the selection has been done
            }

            // Update axis and area position
            xAxis.transition().duration(1000).call(d3.axisBottom(x));
            area
              .select(".myArea")
              .transition()
              .duration(1000)
              .attr("d", areaGenerator);
          }

          // If user double click, reinitialize the chart
          linesvg.on("dblclick", function () {
            x.domain(d3.extent(worldData, (d) => d.date));
            xAxis.transition().call(d3.axisBottom(x));
            area.select(".myArea").transition().attr("d", areaGenerator);
          });
        });
      });
    </script>
  </body>
</html>
